---
layout: post
title: 动态规划注解 
date: 2019-03-12 22:35:48 +0800
categories: technology
tags: [算法]
---

# 什么是动态规划

其实就是动态递推，本质上是 `递归+记忆化`,就拿斐波那契数列来说，其组成形式如 `0，1，1，2，3，5...`,后一项等于前两项之和。即 n<=1时为 f(n)=n，否则 f(n)=f(n-1)+f(n-2),这就是递推公式，递推只需要关注相邻状态，且自底向下推导。

1.递归方案一

``` python
def fib(n):
    return n if n<=1 else fib(n-1)+fib(n-2)
```

这个方案的算法复杂度是O(2^n),因为里面会重复算 `fib(2),fib(3),fib(4),fib(1),fib(0)`,显然算法上不是最优的。

2.递归方案二

``` python
def fib(n):
    cache=[None]*(n+1)
    cache[0]=0
    cache[1]=1
    i=2
    while i<=n:
       cache[i]=cache[i-1]+cache[i-2]
        i+=1
    return cache[n]
```

方案二我们将每次计算的结果都保存至一个缓存变量，这样就减少了重复运算的次数。

## 利用状态转移方程

有一个m行n列的棋盘，一只猫需要从棋盘的最左上角格子走到最右下角格子，且只能横向或竖向移动，棋盘中间有的格子分布有石头，代表此路不通，让我们计算出猫的路径条数。

思路：我们可以从起点格子或终点格子考虑，起点格子的路径等于与其相邻的格子的路径之和，与终点相邻的格子路径分别为1，加起来就是相邻斜线格子的路径数。所以我们递推出状态转移方程：`opt[i,j]=opt[i-1,j]+opt[i,j-1]`，起始点的路径数就是结果值。

``` python
def count_of_paths(m, n, list):
    opt = [([0] * n) for _ in range(m)]
    for i in range(m):
        for j in range(n):
            if list[i][j] == 'E':
                opt[0][j]=1
                opt[i][0]=1
                opt[i][j] = opt[i-1][j] + opt[i][j-1]
            else:
                opt[i][j] = 0
    return opt[-1][-1]

# 构建以终点为原点的坐标系，E代表空地，S代表有石头，C代表终点位置
testdata = [['C', 'E', 'E', 'E', 'E', 'E', 'E', 'E'],
            ['E', 'E', 'S', 'E', 'E', 'E', 'S', 'E']
    , ['E', 'S', 'E', 'S', 'S', 'E', 'E', 'E']
    , ['S', 'E', 'E', 'E', 'E', 'S', 'E', 'E']
    , ['E', 'E', 'S', 'E', 'E', 'S', 'E', 'S']
    , ['E', 'E', 'E', 'S', 'E', 'E', 'E', 'E']
    , ['E', 'S', 'E', 'E', 'E', 'S', 'E', 'E']
    , ['E', 'E', 'E', 'E', 'E', 'E', 'E', 'E']]

print(count_of_paths(8, 8, testdata))
```

这里我们还可以扩展取任意一点的路径数，即找到最优子结构。

## 动态规划 vs 回溯 vs 贪心

- 回溯（递归）：重复计算
- 贪心：永远局部最优
- 动态规划：记录局部最优子结构/多种记录值
